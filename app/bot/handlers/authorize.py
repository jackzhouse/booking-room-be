"""
Handler for /authorize command.
Allows users to authenticate via a code generated by the frontend.
"""
import httpx
from telegram import Update
from telegram.ext import ContextTypes

from app.core.config import settings


async def authorize_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    Handle /authorize command.
    
    Usage: /authorize <code>
    
    User generates a code from the frontend, then sends it to the bot.
    The bot verifies the code and associates the user's Telegram identity with it.
    """
    # Check if code is provided
    if not context.args or len(context.args) != 1:
        await update.message.reply_text(
            "‚ùå Please provide a 6-digit code.\n\n"
            "Usage: /authorize <code>\n\n"
            "Example: /authorize 123456"
        )
        return
    
    code = context.args[0]
    
    # Validate code format (6 digits)
    if not code.isdigit() or len(code) != 6:
        await update.message.reply_text(
            "‚ùå Invalid code format.\n\n"
            "Code must be a 6-digit number.\n\n"
            "Example: /authorize 123456"
        )
        return
    
    # Get user info from Telegram
    user = update.effective_user
    
    if not user:
        await update.message.reply_text("‚ùå Could not identify user.")
        return
    
    # Prepare Telegram user data
    telegram_user_data = {
        "id": user.id,
        "first_name": user.first_name or "",
        "last_name": user.last_name or "",
        "username": user.username,
        "photo_url": None  # Can be enhanced to get photo URL if needed
    }
    
    # Call backend API to verify code
    try:
        async with httpx.AsyncClient(timeout=10.0) as client:
            # Build backend URL
            backend_url = f"{settings.WEBHOOK_BASE_URL}/api/v1/auth/verify-code-telegram"
            
            # Make request
            response = await client.post(
                backend_url,
                params={"code": code},
                json=telegram_user_data
            )
            
            # Parse response
            result = response.json()
            
            if response.status_code == 200 and result.get("verified"):
                # Success! User is authenticated
                user_data = result.get("user_data", {})
                access_token = result.get("access_token")
                
                # Build success message
                message = (
                    f"‚úÖ Authorization successful!\n\n"
                    f"Welcome, {user_data.get('full_name', 'User')}!\n\n"
                )
                
                if user_data.get("is_admin"):
                    message += "üîë You have admin privileges.\n"
                
                if access_token:
                    # Include token in message (or can send via other means)
                    message += f"\nüîê Your access token:\n`{access_token}`\n"
                    message += "\nüí° Use this token to authenticate with the frontend."
                
                await update.message.reply_text(
                    message,
                    parse_mode="Markdown"
                )
            else:
                # Invalid code
                await update.message.reply_text(
                    "‚ùå Invalid or expired code.\n\n"
                    "Please generate a new code from the frontend and try again."
                )
    
    except httpx.TimeoutException:
        await update.message.reply_text(
            "‚è±Ô∏è Request timeout. Please try again."
        )
    except httpx.RequestError as e:
        await update.message.reply_text(
            f"‚ùå Network error: {str(e)}\n\n"
            "Please check your connection and try again."
        )
    except Exception as e:
        await update.message.reply_text(
            f"‚ùå An error occurred: {str(e)}\n\n"
            "Please contact support if the problem persists."
        )