"""
Handler for /authorize command.
Allows users to authenticate via a code generated by the frontend.
"""
import httpx
from telegram import Update
from telegram.ext import ContextTypes

from app.core.config import settings


async def authorize_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    Handle /authorize command.
    
    Usage: /authorize <code>
    
    User generates a code from the frontend, then sends it to the bot.
    The bot verifies the code and associates the user's Telegram identity with it.
    """
    # Check if code is provided
    if not context.args or len(context.args) != 1:
        await update.message.reply_text(
            "âŒ Please provide a 6-digit code.\n\n"
            "Usage: /authorize <code>\n\n"
            "Example: /authorize 123456"
        )
        return
    
    code = context.args[0]
    
    # Validate code format (6 digits)
    if not code.isdigit() or len(code) != 6:
        await update.message.reply_text(
            "âŒ Invalid code format.\n\n"
            "Code must be a 6-digit number.\n\n"
            "Example: /authorize 123456"
        )
        return
    
    # Get user info from Telegram
    user = update.effective_user
    
    if not user:
        await update.message.reply_text("âŒ Could not identify user.")
        return
    
    # Prepare Telegram user data
    telegram_user_data = {
        "id": user.id,
        "first_name": user.first_name or "",
        "last_name": user.last_name or "",
        "username": user.username,
        "photo_url": None  # Can be enhanced to get photo URL if needed
    }
    
    # Call backend API to verify code
    try:
        async with httpx.AsyncClient(timeout=10.0) as client:
            # Build backend URL
            backend_url = f"{settings.WEBHOOK_BASE_URL}/api/v1/auth/verify-code-telegram"
            
            # Make request
            response = await client.post(
                backend_url,
                params={"code": code},
                json=telegram_user_data
            )
            
            # Parse response
            result = response.json()
            
            # Debug logging
            print(f"ğŸ” Authorization attempt - Code: {code}")
            print(f"ğŸ” Status code: {response.status_code}")
            print(f"ğŸ” Response: {result}")
            
            # Check if code was verified successfully
            data = result.get("data", {})
            is_verified = data.get("status") == "verified" and response.status_code == 200
            
            print(f"ğŸ” Is verified: {is_verified}")
            print(f"ğŸ” Data status: {data.get('status')}")
            
            if is_verified:
                # Success! User is authenticated
                user_info = data.get("user", {})
                access_token = data.get("token")
                
                # Build full name
                first_name = user_info.get("first_name", "")
                last_name = user_info.get("last_name", "")
                full_name = f"{first_name} {last_name}".strip() or "User"
                
                # Build success message
                message = (
                    f"âœ… Authorization successful!\n\n"
                    f"Welcome, {full_name}!\n\n"
                )
                
                if user_info.get("is_admin"):
                    message += "ğŸ”‘ You have admin privileges.\n"
                
                if access_token:
                    # Include token in message (or can send via other means)
                    message += f"\nğŸ” Your access token:\n`{access_token}`\n"
                    message += "\nğŸ’¡ Use this token to authenticate with the frontend."
                
                await update.message.reply_text(
                    message,
                    parse_mode="Markdown"
                )
            else:
                # Invalid code
                await update.message.reply_text(
                    "âŒ Invalid or expired code.\n\n"
                    "Please generate a new code from the frontend and try again."
                )
    
    except httpx.TimeoutException:
        await update.message.reply_text(
            "â±ï¸ Request timeout. Please try again."
        )
    except httpx.RequestError as e:
        await update.message.reply_text(
            f"âŒ Network error: {str(e)}\n\n"
            "Please check your connection and try again."
        )
    except Exception as e:
        await update.message.reply_text(
            f"âŒ An error occurred: {str(e)}\n\n"
            "Please contact support if the problem persists."
        )